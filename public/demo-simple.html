<!DOCTYPE html>
<meta charset="utf-8">
<style>
    .node {
        fill: #ccc;
        stroke: #fff;
        stroke-width: 2px;
    }

    .link {
        stroke: #777;
        stroke-width: 2px;
    }
</style>
<body>
    <script src="https://d3js.org/d3.v3.min.js"></script>
    <script>
        var width = 640,
            height = 480;
        
        var links = [
            {source: 'abc1', target:'asf'},
            {source: 'abc1', target:'asf1'},
            {source: 'abc2', target:'asf1'},
        ];

        var nodes = {};

        //parse links to nodes
        links.forEach(function(link){
            link.source = nodes[link.source] ||
                (nodes[link.source] = {name: link.source});
            link.target = nodes[link.target] ||
                (nodes[link.target] = {name: link.target});
        });

        // add svg
        var svg = d3.select('body').append('svg')
            .attr('width', width)
            .attr('height', height);

        var force = d3.layout.force()
            .size([width, height])
            .nodes(d3.values(nodes))
            .links(links)
            .on("tick", tick)
            .linkDistance(300)
            .start();
        
        var link = svg.selectAll('.link')
            .data(links)
            .enter()
            .append('line')
            .attr('class', 'link');
        
        var node = svg.selectAll('.node')
            .data(force.nodes())
            .enter()
            .append('circle')
            .attr('class', 'node')
            .attr('r', width * 0.03);
        
        for (let i = 0; i < 4; ++i) force.tick();
            force.stop();

        function tick(e) {
            node.attr('cx', function(d) { return d.x; })
                .attr('cy', function(d) { return d.y; })
                .call(force.drag); // take this out to make it static
            
            link.attr('x1', function(d) { return d.source.x; })
                .attr('y1', function(d) { return d.source.y; })
                .attr('x2', function(d) { return d.target.x; })
                .attr('y2', function(d) { return d.target.y; });
        }


        /*
        var zoomSettings = {
            duration: 1000,
            ease: d3.easeCubicOut,
            zoomLevel: 5
        };
        
        function clicked(d) {
            var x;
            var y;
            var zoomLevel;

            if (d && centered != d) {
                var centroid = path.centroid(d);
                x = centroid[0];
                y = centroid[1];
                zoomLevel = zoomSettings.zoomLevel;
                centered = d;
            } else {
                x = width / 2;
                y = width / 2;
                zoomLevel = 1;
                centered = null;
            }

            g.transition()
            .duration(zoomSettings.ease)
            .attr('transform', 'translate(' + width / 2 + ', ' + height / 2 + ') scale (' + zoomLevel + ')translate(' + -x + ',' + -y + ')');
        }*/
    </script>


